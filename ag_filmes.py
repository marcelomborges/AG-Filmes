# -*- coding: utf-8 -*-
"""AG_Filmes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fRGrV_j2EzWMEcObAwTyP4aU00xYeiXJ
"""

import pandas as pd
import numpy as np
import random
import math
from operator import itemgetter

numero_geracoes = 1000
tam_populacao = 100
tempo_maximo_dia = 240
taxa_mutacao = 0.2
taxa_cruzamento = 0.9

def leitura_dados(arquivo):
    data = pd.read_csv("Vencedores do Oscar - best-pictures.csv")
    data_frame = pd.DataFrame(data, columns=['title','rating','duration','genre1','genre2'])
    data_frame['rating'] = data_frame['rating'].astype(float)
    lista_filmes_original = data_frame.values.tolist()
    lista_filmes_ordenada = sorted(lista_filmes_original, key=itemgetter(0))

    return lista_filmes_ordenada

def populacao_inicial(quantidade, lista_filmes):
    i = 0
    populacao = []
    individuo = []
    dia = []
    tempo_total = 0

    lista_indices = list(range(0, len(lista_filmes)))

    for i in range(quantidade):
        random.shuffle(lista_indices)
        for indice in lista_indices:
            tempo_filme = duracao_filme(indice, lista_filmes)
            if((tempo_total + tempo_filme) <= tempo_maximo_dia):
                dia.append(indice)
                tempo_total += tempo_filme
            else:
                individuo.append(dia)
                dia = [indice]
                tempo_total = tempo_filme

        populacao.append(individuo)
        individuo = []

    return populacao

def duracao_filme(indice, lista_filmes):
    return lista_filmes[indice][2]

def avaliar_individuo(individuo, lista_filmes):
    return len(individuo)

def avaliar_populacao(populacao, lista_filmes):

    melhor_fitness = 1000
    melhor_individuo = -1

    for i in range(len(populacao)):
        fitness_individuo = avaliar_individuo(populacao[i], lista_filmes)

        if(fitness_individuo < melhor_fitness):
            melhor_individuo = populacao[i]
            melhor_fitness = fitness_individuo

    return [melhor_fitness,melhor_individuo]

#mutacao
def mutacao(filho,lista_filmes):
    mutacao  = random.uniform(0,1)
    if(mutacao < taxa_mutacao):
        dias = list(range(len(filho)))
        d1 = random.randint(0,len(filho)-1)
        dias.remove(d1)
        random.shuffle(dias)
        d2 = dias[random.randint(0,len(dias)-1)]

        if len(filho[d1]) == 1:
          n1 = 0
        else:
          n1 = random.randint(0,len(filho[d1])-1)
        
        if len(filho[d2]) == 1:
          n2 = 0
        else:
          n2 = random.randint(0,len(filho[d2])-1)

        aux = filho[d1][n1]
        filho[d1][n1] = filho[d2][n2]
        filho[d2][n2] = aux
    
    return fix_individuo(filho,lista_filmes)

def intercalarlista(lista1,lista2):
	i = 0
	pais = numpy.zeros(tam_populacao)
	while(i < tam_populacao/2):
			pais[2*i] = lista1[i]
			pais[2*i+1] = lista2[i]
			i += 1
	return pais	

#Cruzamento
    
def crossover(pai1, pai2, lista_filmes):
    filho1 = pai1.copy()
    filho2 = pai2.copy()

    if random.uniform(0, 1) < taxa_cruzamento:
      n1 = random.randint(0,len(pai2)-1)
      n2 = random.randint(0,len(pai2)-1)
      if n2 > n1:
        aux = n2
        n2 = n1
        n1 = aux

      for i in range(n1,n2):
        if i >= len(filho1):
          filho1.append(pai2[i])
        else:
          filho1[i] = pai2[i]
          filho2[i] = pai1[i]
      
      filho1 = fix_individuo(filho1,lista_filmes)
      filho2 = fix_individuo(filho2,lista_filmes)
          

    return (filho1,filho2)


def fix_individuo(individuo, lista_filmes):
  
  # Caso o Godfather 2 esteja antes do Godfather 1, troca ambos de lugar
  encontrou_gf2 = False

  for i in range(len(individuo)):
    dia = individuo[i]
    for j in range(len(dia)):
      filme = dia[j]
      if lista_filmes[filme][0] == "The Godfather":
        if encontrou_gf2: 
          aux = individuo[i][j]
          individuo[i][j] = individuo[dia_gf2][gf2]
          individuo[dia_gf2][gf2] = aux

      if lista_filmes[filme][0] == "The Godfather: Part II":
        encontrou_gf2 = True
        dia_gf2 = i
        gf2 = j
  
  # Remove filmes duplicados e adiciona filmes que estão faltando
  ocorrencias = []
  resto = list(range(len(lista_filmes)))

  i = 0
  while i < len(individuo):
      dia = individuo[i]
      j = 0
      while j < len(dia):
        filme = dia[j]
        if filme not in ocorrencias: # Guarda os filmes que já estão contidos no individuo
            ocorrencias.append(filme)
            resto.remove(filme)
        else: # E remove os filmes que repetiram
            individuo[i][j] = -1
        j += 1
      i += 1

  random.shuffle(resto)
  i = 0
  while i < len(individuo): # No lugar dos filmes que foram removidos, inserimos os filmes que não estão contidos no individuo
      j = 0
      while j < len(individuo[i]):
          if individuo[i][j] == -1:
              if len(resto) > 0:
                individuo[i][j] = resto[0]
                resto.pop(0)
              else:
                del individuo[i][j]
          j += 1
      i += 1



  # Corrige dias com que estão passando do tempo máximo
  i = 0
  while i < len(individuo):
    dia = individuo[i]
    total_tempo = 0
    j = 0
    while j < len(dia):
      filme = dia[j]
      t = duracao_filme(filme, lista_filmes)
      if total_tempo + t > tempo_maximo_dia:
        del dia[j]
        if i+1 < len(individuo):
          individuo[i+1] = [filme] + individuo[i+1]
        else:
          individuo.append([filme])
      else:
        total_tempo = total_tempo + t
      j += 1
    i += 1

  # Redução de dias
  primeira_parada = True
  cap_anterior = 0
  cap = 0
  i = 0
  while i < len(individuo):
      dia = individuo[i]
      j = 0
      while j < len(dia):
        cap = cap + duracao_filme(dia[j],lista_filmes)
        j += 1
      if not primeira_parada:
          if cap + cap_anterior <= tempo_maximo_dia:
              t = individuo[i-1]
              del individuo[i-1]
              i -= 1
              individuo[i] = t + individuo[i]
              cap = cap + cap_anterior
      primeira_parada = False
      cap_anterior = cap
      cap = 0

      i += 1
  
  return individuo


def algoritmo_genetico():

    i = 0
    melhor_resultado = 1000

    lista_filmes = leitura_dados("Vencedores do Oscar - best-pictures.csv")

    populacao = populacao_inicial(tam_populacao, lista_filmes)

    while(i < numero_geracoes):
        retorno = avaliar_populacao(populacao, lista_filmes)

        if(retorno[0] < melhor_resultado):
            melhor_resultado = retorno[0]
            melhor_populacao = retorno[1]

        r =  range(int(math.floor(len(populacao)/2)))
        for j in r:
          ind1 = 2*j
          ind2 = ind1+1
          (populacao[ind1],populacao[ind2]) = crossover(populacao[ind1],populacao[ind2],lista_filmes)
        
        for j in range(len(populacao)):
          populacao[j] = mutacao(populacao[j],lista_filmes)

        #recombinação, mutação e cruzamento
        #nova_populacao = populacao
        if i % 50 == 0:
          print("Geracao:" + str(i))
          print("Fitness:" + str(melhor_resultado))
          print()

        i += 1
    
    print("Resultado: " + str(melhor_resultado) + " - " + str(melhor_populacao))

#PROGRAMA PRINCIPAL
algoritmo_genetico()